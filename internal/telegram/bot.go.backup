package telegram

import (
	"context"
	"fmt"

	"github.com/go-telegram/bot"
	"github.com/go-telegram/bot/models"
)

// Bot wraps the Telegram bot client
type Bot struct {
	bot    *bot.Bot
	chatID int64
}

// NewBot creates a new Telegram bot instance
func NewBot(token string, chatID int64) *Bot {
	opts := []bot.Option{
		bot.WithSkipGetMe(), // Skip validation call to allow testing
	}

	b, err := bot.New(token, opts...)
	if err != nil {
		// In production, we'd return the error, but for now we'll panic
		// since the bot is critical for operation
		panic(fmt.Sprintf("failed to create bot: %v", err))
	}

	return &Bot{
		bot:    b,
		chatID: chatID,
	}
}

// SendMessage sends a message to the configured chat
// Returns the message ID for later editing
// NOTE: Does NOT automatically split - caller must handle long messages
func (b *Bot) SendMessage(ctx context.Context, text string) (int, error) {
	msg, err := b.bot.SendMessage(ctx, &bot.SendMessageParams{
		ChatID:    b.chatID,
		Text:      text,
		ParseMode: models.ParseModeHTML,
	})
	if err != nil {
		return 0, fmt.Errorf("failed to send message: %w", err)
	}

	return msg.ID, nil
}

func (b *Bot) SendMessageWithKeyboard(ctx context.Context, text string, keyboard *models.InlineKeyboardMarkup) (int, error) {
	msg, err := b.bot.SendMessage(ctx, &bot.SendMessageParams{
		ChatID:      b.chatID,
		Text:        text,
		ReplyMarkup: keyboard,
		ParseMode:   models.ParseModeHTML,
	})
	if err != nil {
		return 0, fmt.Errorf("failed to send message with keyboard: %w", err)
	}

	return msg.ID, nil
}

// EditMessage edits an existing message
func (b *Bot) EditMessage(ctx context.Context, messageID int, text string) error {
	_, err := b.bot.EditMessageText(ctx, &bot.EditMessageTextParams{
		ChatID:    b.chatID,
		MessageID: messageID,
		Text:      text,
		ParseMode: models.ParseModeHTML,
	})
	if err != nil {
		return fmt.Errorf("failed to edit message: %w", err)
	}

	return nil
}

// SendTyping sends a typing indicator to the chat
// The indicator expires after 5 seconds, so it should be refreshed every 4 seconds
func (b *Bot) SendTyping(ctx context.Context) error {
	_, err := b.bot.SendChatAction(ctx, &bot.SendChatActionParams{
		ChatID: b.chatID,
		Action: models.ChatActionTyping,
	})
	if err != nil {
		return fmt.Errorf("failed to send typing: %w", err)
	}

	return nil
}

// AnswerCallback answers a callback query
func (b *Bot) AnswerCallback(ctx context.Context, callbackID string) error {
	_, err := b.bot.AnswerCallbackQuery(ctx, &bot.AnswerCallbackQueryParams{
		CallbackQueryID: callbackID,
	})
	if err != nil {
		return fmt.Errorf("failed to answer callback: %w", err)
	}

	return nil
}

// RegisterCommand registers a command handler
func (b *Bot) RegisterCommand(command string, handler bot.HandlerFunc) {
	b.bot.RegisterHandler(bot.HandlerTypeMessageText, "/"+command, bot.MatchTypePrefix, handler)
}

// RegisterCallbackPrefix registers a callback query handler for a specific prefix
func (b *Bot) RegisterCallbackPrefix(prefix string, handler bot.HandlerFunc) {
	b.bot.RegisterHandler(bot.HandlerTypeCallbackQueryData, prefix, bot.MatchTypePrefix, handler)
}

// Start starts the bot with long polling
func (b *Bot) Start(ctx context.Context) {
	b.bot.Start(ctx)
}

type TextHandler func(ctx context.Context, text string)
type CommandHandler func(ctx context.Context, args string)
type CallbackHandler func(ctx context.Context, callbackID, data string)

func (b *Bot) RegisterTextHandler(handler TextHandler) {
	b.bot.RegisterHandlerMatchFunc(func(update *models.Update) bool {
		isMatch := update.Message != nil &&
			update.Message.Text != "" &&
			len(update.Message.Text) > 0 &&
			update.Message.Text[0] != '/'
		return isMatch
	}, func(ctx context.Context, botInstance *bot.Bot, update *models.Update) {
		defer func() {
			if r := recover(); r != nil {
				fmt.Printf("[PANIC] Handler panicked: %v\n", r)
			}
		}()

		handler(ctx, update.Message.Text)
	})
}

func (b *Bot) RegisterCommandHandler(command string, handler CommandHandler) {
	b.bot.RegisterHandler(bot.HandlerTypeMessageText, "/"+command, bot.MatchTypePrefix, func(ctx context.Context, botInstance *bot.Bot, update *models.Update) {
		if update.Message == nil {
			return
		}

		text := update.Message.Text
		args := ""
		if len(text) > len(command)+2 {
			args = text[len(command)+2:]
		}

		handler(ctx, args)
	})
}

func (b *Bot) RegisterCallbackHandler(prefix string, handler CallbackHandler) {
	b.bot.RegisterHandler(bot.HandlerTypeCallbackQueryData, prefix, bot.MatchTypePrefix, func(ctx context.Context, botInstance *bot.Bot, update *models.Update) {
		if update.CallbackQuery == nil {
			return
		}

		b.AnswerCallback(ctx, update.CallbackQuery.ID)
		handler(ctx, update.CallbackQuery.ID, update.CallbackQuery.Data)
	})
}
